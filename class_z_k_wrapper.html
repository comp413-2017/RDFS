<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RDFS: ZKWrapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RDFS
   </div>
   <div id="projectbrief">The Rice Comp413 2017 class&#39; continuation on the work of the 2016 RDFS.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_z_k_wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ZKWrapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7266ad66ba0762fa0abecc20cf0c92aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a7266ad66ba0762fa0abecc20cf0c92aa">ZKWrapper</a> (std::string host, int &amp;error_code, std::string root=&quot;&quot;)</td></tr>
<tr class="separator:a7266ad66ba0762fa0abecc20cf0c92aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c8ce01159a1a8e71d5204c4ff6040a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a38c8ce01159a1a8e71d5204c4ff6040a">prepend_zk_root</a> (const std::string &amp;path) const </td></tr>
<tr class="separator:a38c8ce01159a1a8e71d5204c4ff6040a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64341f0663c10e3644d53d6ea953c23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa64341f0663c10e3644d53d6ea953c23"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>removeZKRoot</b> (const std::string &amp;path) const </td></tr>
<tr class="separator:aa64341f0663c10e3644d53d6ea953c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cfb2015512513a574661e8079f98a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87cfb2015512513a574661e8079f98a4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>removeZKRootAndDir</b> (const std::string &amp;prefix, const std::string &amp;path) const </td></tr>
<tr class="separator:a87cfb2015512513a574661e8079f98a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530a3a5fc37e61f72d73084201d19e2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a530a3a5fc37e61f72d73084201d19e2e">create</a> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, int &amp;error_code, bool ephemeral, bool sync=true) const </td></tr>
<tr class="separator:a530a3a5fc37e61f72d73084201d19e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a3ef3268c7bc953eba110cfc244dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af65a3ef3268c7bc953eba110cfc244dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_ephemeral</b> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, int &amp;error_code, bool sync=true) const </td></tr>
<tr class="separator:af65a3ef3268c7bc953eba110cfc244dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ff8b3a339b6e8f505e5e5408a43544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a08ff8b3a339b6e8f505e5e5408a43544">create_sequential</a> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, std::string &amp;new_path, bool ephemeral, int &amp;error_code, bool sync=true) const </td></tr>
<tr class="separator:a08ff8b3a339b6e8f505e5e5408a43544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c8c60cad7e38e945e6bcf603189d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a85c8c60cad7e38e945e6bcf603189d58">recursive_create</a> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, int &amp;error_code, bool sync=true) const </td></tr>
<tr class="separator:a85c8c60cad7e38e945e6bcf603189d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2629dd6880c17bb7ee4e112d9a3932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a7d2629dd6880c17bb7ee4e112d9a3932">exists</a> (const std::string &amp;path, bool &amp;exist, int &amp;error_code) const </td></tr>
<tr class="separator:a7d2629dd6880c17bb7ee4e112d9a3932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec70acf2e65eddf491eec669fb3b67c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#aec70acf2e65eddf491eec669fb3b67c2">wexists</a> (const std::string &amp;path, bool &amp;exist, watcher_fn watch, void *watcherCtx, int &amp;error_code) const </td></tr>
<tr class="separator:aec70acf2e65eddf491eec669fb3b67c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a8a4582b0f8c625b10619b99d1981a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a55a8a4582b0f8c625b10619b99d1981a">delete_node</a> (const std::string &amp;path, int &amp;error_code, bool sync=true) const </td></tr>
<tr class="separator:a55a8a4582b0f8c625b10619b99d1981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bbbd3a3b26bf474127d124c0da33dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#ad5bbbd3a3b26bf474127d124c0da33dc">recursive_delete</a> (const std::string &amp;path, int &amp;error_code) const </td></tr>
<tr class="separator:ad5bbbd3a3b26bf474127d124c0da33dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae428b88e1f1d0a213b299e20fb5e3bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#aae428b88e1f1d0a213b299e20fb5e3bd">get_children</a> (const std::string &amp;path, std::vector&lt; std::string &gt; &amp;children, int &amp;error_code) const </td></tr>
<tr class="separator:aae428b88e1f1d0a213b299e20fb5e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757e5ee9a55071faa02883caad8c48b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a6757e5ee9a55071faa02883caad8c48b">wget_children</a> (const std::string &amp;path, std::vector&lt; std::string &gt; &amp;children, watcher_fn watch, void *watcherCtx, int &amp;error_code) const </td></tr>
<tr class="separator:a6757e5ee9a55071faa02883caad8c48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743df578deb55cece05f648daf9e1abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a743df578deb55cece05f648daf9e1abd">get</a> (const std::string &amp;path, std::vector&lt; std::uint8_t &gt; &amp;data, int &amp;error_code, int length=MAX_PAYLOAD) const </td></tr>
<tr class="separator:a743df578deb55cece05f648daf9e1abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97463e55b810738ee39199711d52c934"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a97463e55b810738ee39199711d52c934">get_info</a> (const std::string &amp;path, struct Stat &amp;stat, int &amp;error_code) const </td></tr>
<tr class="separator:a97463e55b810738ee39199711d52c934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bbe304fbac8cf3229d1b064b91448d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a97bbe304fbac8cf3229d1b064b91448d">wget</a> (const std::string &amp;path, std::vector&lt; std::uint8_t &gt; &amp;data, watcher_fn watch, void *watcherCtx, int &amp;error_code, int length=MAX_PAYLOAD) const </td></tr>
<tr class="separator:a97bbe304fbac8cf3229d1b064b91448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55907a4c539f391dc576b978f8c82b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#ad55907a4c539f391dc576b978f8c82b7">set</a> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, int &amp;error_code, bool sync=true, int version=-1) const </td></tr>
<tr class="separator:ad55907a4c539f391dc576b978f8c82b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d12dfe93fa12ac56f6b9272b5b5c21"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#aa1d12dfe93fa12ac56f6b9272b5b5c21">build_create_op</a> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, const int flags=0) const </td></tr>
<tr class="separator:aa1d12dfe93fa12ac56f6b9272b5b5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe897d55d9e0d88175894fc154a5bbdf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#afe897d55d9e0d88175894fc154a5bbdf">build_delete_op</a> (const std::string &amp;path, int version=-1) const </td></tr>
<tr class="separator:afe897d55d9e0d88175894fc154a5bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3f45c1f2a3bd194421bdfbe187d0d0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a7a3f45c1f2a3bd194421bdfbe187d0d0">build_set_op</a> (const std::string &amp;path, const std::vector&lt; std::uint8_t &gt; &amp;data, int version=-1) const </td></tr>
<tr class="separator:a7a3f45c1f2a3bd194421bdfbe187d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c175112e76cf7930277df1519bc8b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a03c175112e76cf7930277df1519bc8b1">execute_multi</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt;&gt; operations, std::vector&lt; zoo_op_result &gt; &amp;results, int &amp;error_code, bool sync=true) const </td></tr>
<tr class="separator:a03c175112e76cf7930277df1519bc8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eda1f418e5390b598bd38dce060939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#ac3eda1f418e5390b598bd38dce060939">flush</a> (const std::string &amp;full_path, bool synchronous=true) const </td></tr>
<tr class="separator:ac3eda1f418e5390b598bd38dce060939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c44548c3d0f57a0249ec96491050a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3c44548c3d0f57a0249ec96491050a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> ()</td></tr>
<tr class="separator:aa3c44548c3d0f57a0249ec96491050a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a6926cf9d21ec269e06305f4decf007"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#a1a6926cf9d21ec269e06305f4decf007">translate_error</a> (int error_code)</td></tr>
<tr class="separator:a1a6926cf9d21ec269e06305f4decf007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dca6ed21ec134c5b499a5d903d4a28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74dca6ed21ec134c5b499a5d903d4a28"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>watcher_znode_data</b> (zhandle_t *zzh, int type, int state, const char *path, void *watcherCtx)</td></tr>
<tr class="separator:a74dca6ed21ec134c5b499a5d903d4a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d73935ee0ed77356db360f418966fd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d73935ee0ed77356db360f418966fd4"></a>
static std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_byte_vector</b> (const std::string &amp;string)</td></tr>
<tr class="separator:a1d73935ee0ed77356db360f418966fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea7b0df86c5db283d944e83b21a0ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fea7b0df86c5db283d944e83b21a0ab"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>print_error</b> (int error)</td></tr>
<tr class="separator:a1fea7b0df86c5db283d944e83b21a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aaf979af1f0258b70f15dd0de4a15ffbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf979af1f0258b70f15dd0de4a15ffbd"></a>
static const std::vector<br class="typebreak"/>
&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EMPTY_VECTOR</b> = std::vector&lt;std::uint8_t&gt;(0)</td></tr>
<tr class="separator:aaf979af1f0258b70f15dd0de4a15ffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9c1b65d94bce9fb69d14a2556bf3794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_z_k_wrapper.html#af9c1b65d94bce9fb69d14a2556bf3794">watcher</a> (zhandle_t *zzh, int type, int state, const char *path, void *watcherCtx)</td></tr>
<tr class="separator:af9c1b65d94bce9fb69d14a2556bf3794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7266ad66ba0762fa0abecc20cf0c92aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZKWrapper::ZKWrapper </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>root</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes zookeeper</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The location of where Zookeeper is running. For local development this will usually be 'localhost:2181' </td></tr>
    <tr><td class="paramname">error_code</td><td>Integer reference, set to a value in ZK_ERRORS Otherwise, an error code is returned. The meaning of an error code can be retrieved from <a class="el" href="class_z_k_wrapper.html#a1a6926cf9d21ec269e06305f4decf007">translate_error()</a> </td></tr>
    <tr><td class="paramname">root</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa1d12dfe93fa12ac56f6b9272b5b5c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt; ZKWrapper::build_create_op </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path of znode </td></tr>
    <tr><td class="paramname">data</td><td>data to initialize the node with. Set to the empty string to create an empty znode </td></tr>
    <tr><td class="paramname">flags</td><td>node flags: ZOO_EPHEMERAL, ZOO_SEQUENCE, ZOO_EPHEMERAL || ZOO_SEQUENCE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_zoo_op.html">ZooOp</a> to be used in execute_multi </dd></dl>

</div>
</div>
<a class="anchor" id="afe897d55d9e0d88175894fc154a5bbdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt; ZKWrapper::build_delete_op </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of znode </td></tr>
    <tr><td class="paramname">version</td><td>Checks the version of the znode before deleting. Defaults to -1, which does not perform the check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_zoo_op.html">ZooOp</a> to be used in execute_multi </dd></dl>

</div>
</div>
<a class="anchor" id="a7a3f45c1f2a3bd194421bdfbe187d0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt; ZKWrapper::build_set_op </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td></td></tr>
    <tr><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramname">version</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a530a3a5fc37e61f72d73084201d19e2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ephemeral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a znode in zookeeper</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The location of the new znode within the zookeeper structure </td></tr>
    <tr><td class="paramname">data</td><td>The data contained in this znode </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a08ff8b3a339b6e8f505e5e5408a43544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::create_sequential </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>new_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ephemeral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a sequential znode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the new sequential znode. The last component must end in "-" like: '/foo/bar-'. When the node is created, a 10 digit sequential ID unique to the parent node will be appended to the name. </td></tr>
    <tr><td class="paramname">data</td><td>The data contained in this znode </td></tr>
    <tr><td class="paramname">new_path</td><td>Will contain the value of the newly created path </td></tr>
    <tr><td class="paramname">ephemeral</td><td>If true, the created node will ephemeral </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a55a8a4582b0f8c625b10619b99d1981a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::delete_node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a znode from zookeeper</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the znode that should be deleted </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a03c175112e76cf7930277df1519bc8b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::execute_multi </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_zoo_op.html">ZooOp</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>operations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; zoo_op_result &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs all of the zookeeper operations within the operations vector atomically (without ordering). Atomic execution mean that either all of the operations will succeed, else they will all be rolled back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operations</td><td>a vector of operations to be executed </td></tr>
    <tr><td class="paramname">results</td><td>a vector that maps to the results of each of the executed operations </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation worked successfully; false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d2629dd6880c17bb7ee4e112d9a3932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>exist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a znode exists or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the node </td></tr>
    <tr><td class="paramname">exist</td><td>Set to true if a znode exists at the given path, false otherwise </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="ac3eda1f418e5390b598bd38dce060939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::flush </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>full_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synchronous</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush changes inside of ZooKeeper </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_path</td><td>the full path of the znode directory to be flushed. Must be qualified with the ZooKeeper root </td></tr>
    <tr><td class="paramname">synchronous</td><td>Whether this operation is blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="a743df578deb55cece05f648daf9e1abd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>MAX_PAYLOAD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the data associated with a node</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the node </td></tr>
    <tr><td class="paramname">data</td><td>Reference to a vector which will be filled with the znode data Should be of size MAX_PAYLOAD when passed in, will be resized in this method </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="aae428b88e1f1d0a213b299e20fb5e3bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::get_children </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets a list of children of the znode specified by the path</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of parent node </td></tr>
    <tr><td class="paramname">children</td><td>Reference to a vector which will be populated with the names of the children znodes of the given path TODO: How large should this vector be when passed in? </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a97463e55b810738ee39199711d52c934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::get_info </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct Stat &amp;&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the info associated with a znode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the node </td></tr>
    <tr><td class="paramname">stat</td><td>Reference to a stat struct to be filled with znode info </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a38c8ce01159a1a8e71d5204c4ff6040a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ZKWrapper::prepend_zk_root </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends the ZooKeeper root to all paths passed in </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the original path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated path </dd></dl>

</div>
</div>
<a class="anchor" id="a85c8c60cad7e38e945e6bcf603189d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::recursive_create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively creates a new znode, non-existent znodes in the specified path will be created</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to create </td></tr>
    <tr><td class="paramname">data</td><td>The data to store in the new znode </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="ad5bbbd3a3b26bf474127d124c0da33dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::recursive_delete </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively deletes the znode specified in the path and any children of that path</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path the znode (and its children) which will be deleted </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="ad55907a4c539f391dc576b978f8c82b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data in a given znode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the znode </td></tr>
    <tr><td class="paramname">data</td><td>The data that this znode should contain </td></tr>
    <tr><td class="paramname">version</td><td>A version number indicating changes to the data at this node </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6926cf9d21ec269e06305f4decf007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ZKWrapper::translate_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate numerical error code to zookeeper error string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string translation of the error code </dd></dl>

</div>
</div>
<a class="anchor" id="aec70acf2e65eddf491eec669fb3b67c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::wexists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>exist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">watcher_fn&#160;</td>
          <td class="paramname"><em>watch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>watcherCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to 'exists' except it allows the caller to specify a watcher object rather than a boolean watch flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the znode that needs to be checked </td></tr>
    <tr><td class="paramname">exist</td><td>Set to true if a znode exists at the given path, false otherwise </td></tr>
    <tr><td class="paramname">watch</td><td>A watcher function </td></tr>
    <tr><td class="paramname">watcherCtx</td><td>User specific data, will be passed to the watcher callback. </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a97bbe304fbac8cf3229d1b064b91448d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::wget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">watcher_fn&#160;</td>
          <td class="paramname"><em>watch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>watcherCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>MAX_PAYLOAD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to 'get' except it allows one to specify a watcher object rather than a boolean watch flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the node </td></tr>
    <tr><td class="paramname">data</td><td>Reference to a vector which will be filled with the znode data Should be of size MAX_PAYLOAD when passed in, will be resized in this method </td></tr>
    <tr><td class="paramname">watch</td><td>A watcher function </td></tr>
    <tr><td class="paramname">watcherCtx</td><td>User specific data, will be passed to the watcher callback. </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<a class="anchor" id="a6757e5ee9a55071faa02883caad8c48b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZKWrapper::wget_children </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">watcher_fn&#160;</td>
          <td class="paramname"><em>watch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>watcherCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to 'get_children', except it allows one to specify a watcher object rather than a boolean watch flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to get children of and the node to place the watch on </td></tr>
    <tr><td class="paramname">children</td><td>Reference to a vector which will be populated with the names of the children znodes of the given path TODO: How large should this vector be when passed in? </td></tr>
    <tr><td class="paramname">watch</td><td>A watcher function </td></tr>
    <tr><td class="paramname">watcherCtx</td><td>User specific data, will be passed to the watcher callback. </td></tr>
    <tr><td class="paramname">error_code</td><td>Int reference, set to a value in ZK_ERRORS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation completed successfully, False otherwise (caller should check 'error_code' value) </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="af9c1b65d94bce9fb69d14a2556bf3794"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void watcher </td>
          <td>(</td>
          <td class="paramtype">zhandle_t *&#160;</td>
          <td class="paramname"><em>zzh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>watcherCtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Currently watches the zookeeper handle and closes zookeeper on failed auths or expired sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zzh</td><td>zookeeper handle </td></tr>
    <tr><td class="paramname">type</td><td>type of event </td></tr>
    <tr><td class="paramname">state</td><td>state of the event </td></tr>
    <tr><td class="paramname">path</td><td>path to the watcher node </td></tr>
    <tr><td class="paramname">watcherCtx</td><td>the state of the watcher </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>zkwrapper/include/<a class="el" href="zkwrapper_8h_source.html">zkwrapper.h</a></li>
<li>zkwrapper/source/zkwrapper.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
